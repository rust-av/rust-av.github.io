<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta http-equiv=x-ua-compatible content="ie=edge"><link rel=apple-touch-icon sizes=120x120 href=https://mindfreeze.videolan.me/rust-av/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://mindfreeze.videolan.me/rust-av/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://mindfreeze.videolan.me/rust-av/favicon-16x16.png><link rel=manifest href=https://mindfreeze.videolan.me/rust-av/manifest.json><meta name=theme-color content=#ffffff><link rel=stylesheet href=https://mindfreeze.videolan.me/rust-av/css/bootstrap-reboot.css><link rel=stylesheet href=https://mindfreeze.videolan.me/rust-av/css/bootstrap.css><link rel=stylesheet href=https://mindfreeze.videolan.me/rust-av/css/font-awesome.min.css><link rel=stylesheet href=https://mindfreeze.videolan.me/rust-av/css/rav1e.css><title>Implementing Tile Encoding in rav1e - Rust AV</title></head><body><header class="navbar navbar-expand navbar-dark flex-column flex-md-row tk-navbar"><a class=navbar-brand href=https://mindfreeze.videolan.me/rust-av/><img src=https://mindfreeze.videolan.me/rust-av/img/logo.png class=align-middle alt></a><div class="collapse navbar-collapse"><ul class=navbar-nav><li class=nav-item><a class=nav-link href=https://mindfreeze.videolan.me/rust-av/>Home</a></li><li class=nav-item><a class="nav-link  active" href=https://mindfreeze.videolan.me/rust-av/blog/2019-04-25-implementing-tile-encoding-in-rav1e./>Blog</a></li><li class=nav-item><a class=nav-link href=https://mindfreeze.videolan.me/rust-av/community/>Community</a></li></ul></div><ul class="navbar-nav flex-row ml-md-auto d-none d-md-flex"><li class=nav-item><a class="nav-link p-2" href=https://github.com/rust-av target=_blank rel=noopener aria-label=GitHub><svg class="navbar-nav-svg" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 499.36" focusable="false"><title>GitHub</title><path d="M256 0C114.64.0.0 114.61.0 256c0 113.09 73.34 209 175.08 242.9 12.8 2.35 17.47-5.56 17.47-12.34.0-6.08-.22-22.18-.35-43.54-71.2 15.49-86.2-34.34-86.2-34.34-11.64-29.57-28.42-37.45-28.42-37.45-23.27-15.84 1.73-15.55 1.73-15.55 25.69 1.81 39.21 26.38 39.21 26.38 22.84 39.12 59.92 27.82 74.5 21.27 2.33-16.54 8.94-27.82 16.25-34.22-56.84-6.43-116.6-28.43-116.6-126.49.0-27.95 10-50.8 26.35-68.69-2.63-6.48-11.42-32.5 2.51-67.75.0.0 21.49-6.88 70.4 26.24a242.65 242.65.0 0 1 128.18.0c48.87-33.13 70.33-26.24 70.33-26.24 14 35.25 5.18 61.27 2.55 67.75 16.41 17.9 26.31 40.75 26.31 68.69.0 98.35-59.85 120-116.88 126.32 9.19 7.9 17.38 23.53 17.38 47.41.0 34.22-.31 61.83-.31 70.23.0 6.85 4.61 14.81 17.6 12.31C438.72 464.97 512 369.08 512 256.02 512 114.62 397.37.0 256 0z" fill="currentcolor" fill-rule="evenodd" /></svg></a></li></ul></header><div class="container-fluid tk-blog"><div class="row flex-xl-nowrap"><div class="col-12 col-md-3 col-xl-2 tk-sidebar"><div class="tk-docs-toggle d-md-none p-0 d-flex ml-3 collapsed align-item-center"><h1 class=tk-title>Implementing Tile Encoding in rav1e</h1><button class="btn btn-link" type=button data-toggle=collapse data-target=#tk-docs-nav aria-controls=tk-docs-nav aria-expanded=false aria-label="Toggle docs navigation"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 30 30" width="30" height="30" focusable="false"><title>Menu</title><path stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-miterlimit="10" d="M4 7h22M4 15h22M4 23h22"/></svg></button></div><nav class="tk-links collapse" id=tk-docs-nav><div class="tk-toc-item active"><p class=tk-toc-link>Blog Posts</p><ul class="nav tk-sidenav"><li><a href=https://mindfreeze.videolan.me/rust-av/blog/2019-04-25-implementing-tile-encoding-in-rav1e./ class=active>Implementing Tile Encoding in rav1e</a></li><li><a href=https://mindfreeze.videolan.me/rust-av/blog/2019-04-09-using-rav1e-from-your-code/>Using rav1e - from your own code</a></li><li><a href=https://mindfreeze.videolan.me/rust-av/blog/2019-02-18-why-you-should-care-about-aom-analyzer-tool-e2808b/>Why you should care about AOM Analyzer</a></li></ul></div></nav></div><div class="d-none d-xl-block col-xl-4 tk-toc"><div class=section-nav><nav id=TableOfContents><ul><li><ul><li><a href=#what-is-this>What is this?</a><ul><li><a href=#tile-encoding>Tile encoding</a></li></ul></li><li><a href=#preliminary-work>Preliminary work</a></li><li><a href=#tiling-structures>Tiling structures</a><ul><li><a href=#minimal-example>Minimal example</a></li><li><a href=#in-rav1e>In rav1e</a></li><li><a href=#relative-offsets>Relative offsets</a></li></ul></li><li><a href=#tile-encoding-1>Tile encoding</a></li><li><a href=#command-line>Command-line</a></li><li><a href=#bitstream>Bitstream</a><ul><li><a href=#tile-info>Tile info</a><ul><li><a href=#cdf-update>CDF update</a></li><li><a href=#size-of-tiles-size>Size of tiles size</a></li></ul></li><li><a href=#tile-group>Tile group</a></li></ul></li><li><a href=#parallelization>Parallelization</a><ul><li><a href=#limits>Limits</a></li></ul></li><li><a href=#fixing-bugs>Fixing bugs</a></li><li><a href=#conclusion>Conclusion</a></li></ul></li></ul></nav></div></div><main class="col-12 col-md-9 col-xl-7 py-md-3 pl-md-3 tk-content tk-docs"><h1 class=tk-title>Implementing Tile Encoding in rav1e</h1><p class=tk-date>Romain Vimont</p><p>During the last few months at <a href=https://videolabs.io>Videolabs</a>, I added support for <a href=https://github.com/xiph/rav1e/pull/1126>tile
encoding</a> in <a href="a Rust AV1 Encoder">rav1e</a>.</p><h2 id=what-is-this>What is this?</h2><p><a href=https://en.wikipedia.org/wiki/AV1>AV1</a> is an open and royalty-free video coding format, concurrent with <a href=H.265>HEVC</a>.</p><p><a href="https://www.youtube.com/watch?v=ytsRYKQc6kQ">Rav1e</a> is an encoder written in <a href=https://www.rust-lang.org/>Rust</a>, developped by
<a href=https://research.mozilla.org/av1-media-codecs/>Mozilla</a>/<a href=https://xiph.org/>Xiph</a>. As such, it takes an input video and encodes it
to produce a valid AV1 bitstream.</p><h3 id=tile-encoding>Tile encoding</h3><p>Tile encoding consists in splitting video frames into <em>tiles</em> that can be
encoded and decoded independently in parallel (to use several CPUs), at the cost
of a small loss in compression efficiency.</p><p>This speeds up encoding and increases decoding frame rate.</p><p>{: .center}
[![tiles][tiles]][tiles]<br><em>8 tiles (4 colums × 2 rows)</em></p><p>[tiles]: {{ site.assets }}/rav1e_tile_encoding/tiles.jpg</p><h2 id=preliminary-work>Preliminary work</h2><p>To prepare for tiling, some refactoring was necessary.</p><p>A <em>frame</em> contains 3 <em>planes</em> (one for each <a href=https://en.wikipedia.org/wiki/YUV>YUV</a> component, possibly
<a href=https://en.wikipedia.org/wiki/Chroma_subsampling>subsampled</a>). Each plane is stored in a contiguous array, rows after rows.</p><p>To illustrate it, here is a mini-plane containing 6×3 pixels. Padding is
added for alignment (and other details), so its physical size is 8×4 pixels:</p><p>{: .center .no-radius}
<img src="{{ site.assets }}/rav1e_tile_encoding/plane.png" alt=plane></p><p>In memory, it is stored in a single array:</p><p>{: .center .no-radius}
<img src="{{ site.assets }}/rav1e_tile_encoding/plane_memory.png" alt="plane memory"></p><p>The number of array items separating one pixel to the one below is called the
<a href=https://en.wikipedia.org/wiki/Stride_of_an_array>stride</a>. Here, the stride is 8.</p><p>The encoder often needs to process rectangular regions. For that purpose, many
functions received a slice of the plane array and the stride value:</p><p>{% highlight rust %}
pub fn write_forty_two(slice: &amp;mut [u16], stride: usize) {
for y in 0..2 {
for x in 0..4 {
slice[y * stride + x] = 42;
}
}
}
{% endhighlight %}</p><p>This works fine, but the plane slice spans multiple rows.</p><p>Let&rsquo;s split our planes into 4 tiles (2 columns × 2 rows):</p><p>{: .center .no-radius}
<img src="{{ site.assets }}/rav1e_tile_encoding/plane_regions.png" alt="plane regions"></p><p>In memory, the resulting plane regions are not contiguous:</p><p>{: .center .no-radius}
<img src="{{ site.assets }}/rav1e_tile_encoding/plane_regions_memory.png" alt="plane regions memory"></p><p>In Rust, it is not sufficient not to read/write the same memory from several
threads, it must be impossible to write (safe) code that could do it. More
precisely, a mutable reference may not alias any other reference to the same
memory.</p><p>As a consequence, passing <strong>a mutable slice</strong> (<code>&amp;mut [u16]</code>) <strong>spanning multiple
rows is incompatible with tiling</strong>. Instead, we need some structure, implemented
with <a href=https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html>unsafe</a> code, providing a view of the authorized region of the underlying
plane.</p><p>As a first step, I replaced every piece of code which used a raw slice and the
stride value by the existing <a href=https://github.com/xiph/rav1e/pull/1035><code>PlaneSlice</code></a> and <a href=https://github.com/xiph/rav1e/pull/1043><code>PlaneMutSlice</code></a>
structures (which first required to <a href=https://github.com/xiph/rav1e/pull/1002>make planes generic</a> after
<a href=https://github.com/xiph/rav1e/pull/996>improving the <code>Pixel</code> trait</a>).</p><p>After these changes, our function could be rewritten as follow:</p><p>{% highlight rust %}
pub fn write_forty<em>two<t: pixel>(slice: &amp;mut PlaneMutSlice&lt;&rsquo;</em>, T&gt;) {
for y in 0..2 {
for x in 0..4 {
slice[y][x] = 42;
}
}
}
{% endhighlight %}</p><h2 id=tiling-structures>Tiling structures</h2><p>So now, all the code using a raw slice and a stride value has been replaced. But
if we look at the definition of <a href=https://github.com/xiph/rav1e/blob/65ac94db7ba3c67c967b96e80c724e17b7414812/src/plane.rs#L582-L586><code>PlaneMutSlice</code></a>, we see that it still borrows
the whole plane:</p><p>{% highlight rust %}
pub struct PlaneMutSlice&lt;&lsquo;a, T: Pixel&gt; {
pub plane: &amp;&lsquo;a mut Plane<t>,
pub x: isize,
pub y: isize
}
{% endhighlight %}</p><p>So the refactoring, in itself, does not solves the problem.</p><p>What is needed now is a structure that exposes a bounded region of the plane.</p><h3 id=minimal-example>Minimal example</h3><p>For illustration purpose, let&rsquo;s consider a minimal example, solving a similar
problem: <strong>split a matrix into columns</strong>.</p><p>{: .center .no-radius}
<img src="{{ site.assets }}/rav1e_tile_encoding/2d_array.png" alt="2D array"></p><p>In memory, the matrix is stored in a single array:</p><p>{: .center .no-radius}
<img src="{{ site.assets }}/rav1e_tile_encoding/2d_array_memory.png" alt="2D array memory"></p><p>To do so, let&rsquo;s define a <code>ColumnMut</code> type, and split the raw array into columns:</p><p>{% highlight rust %}
use std::marker::PhantomData;
use std::ops::{Index, IndexMut};</p><p>pub struct ColumnMut&lt;&lsquo;a&gt; {
data: *mut u8,
cols: usize,
rows: usize,
phantom: PhantomData&lt;&amp;&lsquo;a mut u8&gt;,
}</p><p>impl Index<usize> for ColumnMut&lt;&rsquo;_&gt; {
type Output = u8;
fn index(&amp;self, index: usize) -&gt; &amp;Self::Output {
assert!(index &lt; self.rows);
unsafe { &amp;*self.data.add(index * self.cols) }
}
}</p><p>impl IndexMut<usize> for ColumnMut&lt;&rsquo;_&gt; {
fn index_mut(&amp;mut self, index: usize) -&gt; &amp;mut Self::Output {
assert!(index &lt; self.rows);
unsafe { &amp;mut *self.data.add(index * self.cols) }
}
}</p><p>pub fn columns(
slice: &amp;mut [u8],
cols: usize,
) -&gt; impl Iterator<item ="ColumnMut<'_">&gt; {
assert!(slice.len() % cols == 0);
let rows = slice.len() / cols;
(0..cols).map(move |col| ColumnMut {
data: &amp;mut slice[col],
cols,
rows,
phantom: PhantomData,
})
}
{% endhighlight %}</p><p>The <a href=https://doc.rust-lang.org/nomicon/phantom-data.html><code>PhantomData</code></a> is necessary to bind the lifetime (in practice,
when we store a raw pointer, we often need a <code>PhantomData</code>).</p><p>We implemented <a href=https://doc.rust-lang.org/std/ops/trait.Index.html><code>Index</code></a> and <a href=https://doc.rust-lang.org/std/ops/trait.IndexMut.html><code>IndexMut</code></a> traits to provide operator <code>[]</code>:</p><p>{% highlight rust %}
// via Index trait
let value = column[y];</p><p>// via IndexMut trait
column[y] = value;
{% endhighlight %}</p><p>The iterator returned by <code>columns()</code> yields a different column every time, so
the borrowing rules are respected.</p><p>Now, we can read from and write to a matrix via temporary column views:</p><p>{% highlight rust %}
fn main() {
let mut data = [1, 5, 3, 2,
4, 2, 1, 7,
0, 0, 0, 0];</p><pre><code>// for each column, write the sum
columns(&amp;mut data, 4).for_each(|mut col| col[2] = col[0] + col[1]);

assert_eq!(data, [1, 5, 3, 2,
                  4, 2, 1, 7,
                  5, 7, 4, 9]);
</code></pre><p>}
{% endhighlight %}</p><p>Even if the columns are interlaced in memory, from a <code>ColumnMut</code> instance, it is
not possible to access data belonging to another column.</p><p><em>Note that <code>cols</code> and <code>rows</code> fields must be kept private, otherwise they could
be changed from safe code in such a way that breaks boundaries and violates
borrowing rules.</em></p><h3 id=in-rav1e>In rav1e</h3><p>A plane is split in a similar way, except that it provides <em>plane regions</em>
instead of <em>colums</em>.</p><p>The split is <em>recursive</em>. For example, a <a href=https://github.com/xiph/rav1e/blob/65ac94db7ba3c67c967b96e80c724e17b7414812/src/encoder.rs#L45-L47><code>Frame</code></a> contains 3 <a href=https://github.com/xiph/rav1e/blob/65ac94db7ba3c67c967b96e80c724e17b7414812/src/plane.rs#L136-L139><code>Plane</code></a>s, so a
<a href=https://github.com/xiph/rav1e/blob/65ac94db7ba3c67c967b96e80c724e17b7414812/src/tiling/tile.rs#L98-L100><code>Tile</code></a> contains 3 <a href=https://github.com/xiph/rav1e/blob/65ac94db7ba3c67c967b96e80c724e17b7414812/src/tiling/plane_region.rs#L109-L115><code>PlaneRegion</code></a>s, using the same underlying memory.</p><p>In practice, more structures related to the encoding state are split into tiles,
provided both in <em>const</em> and <em>mut</em> versions, so there is a whole hierarchy of
tiling structures:</p><pre><code> +- FrameState → TileState
 |  +- Frame → Tile
 |  |  +- Plane → PlaneRegion
 |  +  RestorationState → TileRestorationState
 |  |  +- RestorationPlane → TileRestorationPlane
 |  |     +- FrameRestorationUnits → TileRestorationUnits
 |  +  FrameMotionVectors → TileMotionVectors
 +- FrameBlocks → TileBlocks
</code></pre><p>The split is done by a separate component (see <a href=https://github.com/xiph/rav1e/blob/65ac94db7ba3c67c967b96e80c724e17b7414812/src/tiling/tiler.rs><code>tiler.rs</code></a>), which yields a
<em>tile context</em> containing an instance of the hierarchy of tiling views for each
tile.</p><h3 id=relative-offsets>Relative offsets</h3><p>A priori, there are mainly two possibilities to express offsets during tile
encoding:
- relative to the tile;
- relative to the frame (i.e. absolute).</p><p>The usage of tiling views strongly favors the first choice. For example, it
would be confusing if a bounded region could not be indexed from 0:</p><p>{% highlight rust %}
// region starting at (64, 64)
let row = &amp;region[0]; // panic, out-of-bounds
let row = &amp;region[64]; // ok :-/
{% endhighlight %}</p><p>Worse, this would not be possible at all for the second dimension:</p><p>{% highlight rust %}
// region starting at (64, 64)
let first_row = &amp;region[64];
let first_column = row[64]; // wrong, a raw slice necessarily starts at 0
{% endhighlight %}</p><p>Therefore, offsets used in tiling views are relative to the tile (contrary to
<em>libaom</em> and AV1 specification).</p><h2 id=tile-encoding-1>Tile encoding</h2><p>Encoding a frame first involves frame-wise accesses (initialization), then
tile-wise accesses (to encode tiles in parallel), then frame-wise accesses using
the results of tile-encoding (<a href=https://en.wikipedia.org/wiki/Deblocking_filter>deblocking</a>, <a href=https://hacks.mozilla.org/2018/06/av1-next-generation-video-the-constrained-directional-enhancement-filter/>CDEF</a>, <a href="https://www.youtube.com/watch?v=On9VOnIBSEs&amp;t=1335">loop restoration</a>, …).</p><p>All the frame-level structures have been replaced by tiling views where
necessary.</p><p>The tiling views exist only temporarily, during the calls to
<a href=https://github.com/xiph/rav1e/blob/65ac94db7ba3c67c967b96e80c724e17b7414812/src/encoder.rs#L2113-L2122><code>encode_tile()</code></a>. While they are alive, it is not possible to
access frame-level structures (the borrow checker statically prevents it).</p><p>Then the tiling structures vanish, and frame-level processing can continue.</p><p>This <a href=https://github.com/xiph/rav1e/pull/1126>schema</a> gives an overview:</p><pre><code>                                \
      +----------------+         |
      |                |         |
      |                |         |  Frame-wise accesses
      |                |          &gt;
      |                |         |   - FrameState&lt;T&gt;
      |                |         |   - Frame&lt;T&gt;
      +----------------+         |   - Plane&lt;T&gt;
                                /    - ...

              ||   tiling views
              \/
                                \
  +---+  +---+  +---+  +---+     |
  |   |  |   |  |   |  |   |     |  Tile encoding (possibly in parallel)
  +---+  +---+  +---+  +---+     |
                                 |
  +---+  +---+  +---+  +---+     |  Tile-wise accesses
  |   |  |   |  |   |  |   |      &gt;
  +---+  +---+  +---+  +---+     |   - TileStateMut&lt;'_, T&gt;
                                 |   - TileMut&lt;'_, T&gt;
  +---+  +---+  +---+  +---+     |   - PlaneRegionMut&lt;'_, T&gt;
  |   |  |   |  |   |  |   |     |
  +---+  +---+  +---+  +---+     |
                                /

              ||   vanishing of tiling views
              \/
                                \
      +----------------+         |
      |                |         |
      |                |         |  Frame-wise accesses
      |                |          &gt;
      |                |         |  (deblocking, CDEF, ...)
      |                |         |
      +----------------+         |
                                /
</code></pre><h2 id=command-line>Command-line</h2><p>To enable tile encoding, parameters have been added to pass the (log2) number of
tiles <code>--tile-cols-log2</code> and <code>--tile-rows-log2</code>. For example, to request 2x2
tiles:</p><pre><code>rav1e video.y4m -o video.ivf --tile-cols-log2 1 --tile-rows-log2 1
</code></pre><p><em>Currently, we need to pass the log2 of the number of tiles (like in libaom,
even if the <code>aomenc</code> options are called <code>--tile-columns</code> and <code>--tile-rows</code>), to
avoid any confusion. Maybe we could find a better option which is both correct,
non-confusing and user-friendly later.</em></p><h2 id=bitstream>Bitstream</h2><p>Now that we can encode tiles, we must write them according to the <a href=https://aomediacodec.github.io/av1-spec/>AV1
bitstream specification</a>, so that decoders can read the resulting file
correctly.</p><p>Before tile encoding (i.e. with a single tile), rav1e produced a correct
bitstream. Several changes were necessary to write multiple tiles.</p><h3 id=tile-info>Tile info</h3><p>According to <a href=https://aomediacodec.github.io/av1-spec/#tile-info-syntax>Tile info syntax</a>, the <a href=https://github.com/xiph/rav1e/blob/65ac94db7ba3c67c967b96e80c724e17b7414812/src/header.rs#L620-L649>frame header</a> signals the number of columns
and rows of tiles (it always signaled a single tile before).</p><p>In addition, when there are several tiles, it signals two more values, described
below.</p><h4 id=cdf-update>CDF update</h4><p>For <a href=https://en.wikipedia.org/wiki/Entropy_encoding>entropy coding</a>, the encoder maintain and update a CDF (Cumulative
Distribution Function), representing the probabilities of symbols.</p><p>After a frame is encoded, the current CDF state is saved to be possibly used as
a starting state for future frames.</p><p>But with tile encoding, each tile finishes with its own CDF state, so which one
should we associate to the reference frame? The answer is: any of them. But we
must signal the one we choose, in <code>context_update_tile_id</code>; the decoder needs it
to decode the bitstream.</p><p>In practice, we keep the CDF from the <a href=https://github.com/xiph/rav1e/commit/ec82d8016db737de51977effb7746eb1137d675b>biggest tile</a>.</p><h4 id=size-of-tiles-size>Size of tiles size</h4><p>The size of an encoded tile, in bytes, is variable (of course). Therefore, we
will need to signal the size of each tile.</p><p>To gain a few bytes, the number of bytes used to store the size itself is also
variable, and signaled by 2 bits in the frame header
(<code>tile_size_bytes_minus_1</code>).</p><p>Concretely, we must choose the <a href=https://github.com/xiph/rav1e/commit/9a76ff083d97e39b3314f36576994ea99076f996>smallest size</a> that is
sufficient to encode all the tile sizes for the frame.</p><h3 id=tile-group>Tile group</h3><p>According to <a href=https://aomediacodec.github.io/av1-spec/#general-tile-group-obu-syntax>General tile group OBU syntax</a>, we need to <a href=https://github.com/xiph/rav1e/blob/65ac94db7ba3c67c967b96e80c724e17b7414812/src/encoder.rs#L2177-L2195>signal</a>
two values when there are more than 1 tile:
- <code>tile_start_and_end_present_flag</code> (we always disable it);
- <code>tile_size_minus_1</code>.</p><p>The tile size (minus 1) is written in <a href=https://en.wikipedia.org/wiki/Endianness>little endian</a>, and use the
number of bytes we signaled in the frame header.</p><p>That&rsquo;s all. This is sufficient to produce a correct bitstream with multiple
tiles.</p><h2 id=parallelization>Parallelization</h2><p>Thanks to <a href=https://github.com/rayon-rs/rayon>Rayon</a>, <a href=https://github.com/xiph/rav1e/commit/156cc72edf03b5605844b4ecae84dee647fda221>parallelizing</a> tile encoding is as easy as replacing
<code>iter_mut()</code> by <code>par_iter_mut()</code>.</p><p>I tested on my laptop (8 CPUs) several encodings to compare encoding performance
(this is not a good benchmark, but it gives an idea, you are encouraged to run
your own tests). Here are the <a href=https://github.com/xiph/rav1e/pull/1126#issuecomment-484667610>results</a>:</p><pre><code> tiles     time      speedup
   1    7mn02,336s    1.00×
   2    3mn53,578s    1.81×
   4    2mn12,995s    3.05×
   8*   1mn57,533s    3.59×
</code></pre><p>Speedups are quite good for 2 and 4 tiles.</p><p>*The reason why the speedup is lower than expected for 8 tiles is that my CPU
has actually only 4 physical cores. See <a href=https://www.reddit.com/r/programming/comments/bh6sq8/implementing_tile_encoding_in_rav1e_a_rust_av1/elrl5yo/>this reddit comment</a> and
<a href=https://www.reddit.com/r/rust/comments/bh8xnl/implementing_tile_encoding_in_rav1e_a_rust_av1/elrloye/>this other one</a>.</p><h3 id=limits>Limits</h3><p>Why not 2×, 4× and 8× speedup? Mainly because of <a href=https://en.wikipedia.org/wiki/Amdahl%27s_law#Parallel_programs>Amdahl&rsquo;s law</a>.</p><p>Tile encoding parallelizes only a part of the whole process: there are still
single-threaded processings at frame-level.</p><p>Suppose that a proportion <em>p</em> (between 0 and 1) of a given task can be
parallelized. Then its theoretical speedup is <code>1 / ((p/n) + (1-p))</code>, where <em>n</em>
is the number of threads.</p><pre><code> tiles   speedup   speedup   speedup
         (p=0.9)   (p=0.95)  (p=0.98)
   2      1.82×     1.90×     1.96×
   4      3.07×     3.48×     3.77×
   8      4.71×     5.93×     7.02×
</code></pre><p>Maybe counterintuitively, <strong>to increase the speedup brought by parallelization,
non-parallelized code must be optimized</strong> (the more threads are used, the more
the non-parallelized code represents a significant part).</p><p>The (not-so-reliable) benchmark results for 2 and 4 tiles suggest that tile
encoding represents ~90% of the whole encoding process.</p><h2 id=fixing-bugs>Fixing bugs</h2><p>Not everything worked the first time.</p><p>The most common source of errors while implementing tile encoding was related to
offsets.</p><p>When there was only one tile, all offsets were relative to the frame. With
several tiles, some offsets are relative to the current tile, but some others
are still relative to the whole frame. For example, during <a href=https://en.wikipedia.org/wiki/Motion_estimation>motion estimation</a>,
a motion vector can point outside tile boundaries in the reference frame, so we
must take care to convert offsets accordingly.</p><p>The most obvious errors were catched by <em>plane regions</em> (which prevent access
outside boundaries), but some others were more subtle.</p><p>Such errors could produce interesting images. For example, here is a screenshot
of my first tiled video:</p><p>{: .center }
[![bbb][bbb]][bbb]</p><p>[bbb]: {{ site.assets }}/rav1e_tile_encoding/bbb_tiling.jpg</p><p>One of these offsets confusions had been quickly catched by <a href=https://github.com/barrbrain/>barrbrain</a> in
<a href=https://github.com/xiph/rav1e/commit/855b6d06cd2c321d50b7bab8a339c98833502bf3>intra-prediction</a>. I then fixed a similar problem in
<a href=https://github.com/xiph/rav1e/commit/bab3903425a1a9086613de5473bd4282c416c671>inter-prediction</a>.</p><p>But the <a href=https://en.wikipedia.org/wiki/Boss_(video_gaming)#Final_boss>final boss</a> bug was way more sneaky: it corrupted the bitstream (so the
encoder was unable to decode), but not always, and never the first frame. When
an inter-frame could be decoded, it was sometimes <a href=https://github.com/xiph/rav1e/pull/1126#issuecomment-482597763>visually corrupted</a>, but only
for some videos and for some encoding parameters.</p><p>After more than one week of investigations, I finally <a href=https://github.com/xiph/rav1e/commit/4984e0737984fd0d31894d5d5ebc8e89a248c3ab>found it</a>.
<code>\o/</code></p><h2 id=conclusion>Conclusion</h2><p>Implementing this feature was an awesome journey. I learned a lot, both about
Rust and video encoding (I didn&rsquo;t even know what a tile was before I started).</p><p>Big thanks to the Mozilla/Xiph/Daala team, who has been very welcoming and
helpful, and who does amazing work!</p><p><em>Discuss on <a href=https://www.reddit.com/r/programming/comments/bh6sq8/implementing_tile_encoding_in_rav1e_a_rust_av1/>r/programming</a>, <a href=https://www.reddit.com/r/rust/comments/bh8xnl/implementing_tile_encoding_in_rav1e_a_rust_av1/>r/rust</a>, <a href=https://www.reddit.com/r/AV1/comments/bh8xsy/implementing_tile_encoding_in_rav1e/>r/AV1</a> and <a href="https://news.ycombinator.com/item?id=19746392">Hacker News</a>.</em></p></main></div></div><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js integrity=sha384-3ceskX3iaEnIogmQchP8opvBy3Mi7Ce34nWjpBIwVTHfGYWQS9jwHDVRnpKKHJg7 crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/tether/1.3.7/js/tether.min.js integrity=sha384-XTs3FgkjiBgo8qjEjBk0tGmf3wPrWtA6coPfQDfFEY8AnYJwjalXCiosYRBIBZX8 crossorigin=anonymous></script><script src=https://mindfreeze.videolan.me/rust-av/js/bootstrap.min.js></script><script src=https://mindfreeze.videolan.me/rust-av/js/highlight.js></script><script>$(function(){$("pre code").each(function(i,block){if(block.className.indexOf('language-rust')>=0){var new_content='';var lines=block.textContent.split('\n');for(var i=0;i<lines.length;i++){if(lines[i].indexOf('# ')==0||lines[i]=='#'){continue}
new_content+=lines[i].trimRight()+'\n';}
block.textContent=new_content.replace(/\n\n\n/g,"\n\n").trimRight();}
hljs.highlightBlock(block);});});</script><script>$(document).ready(function(){let data;fetch('https://api.github.com/orgs/rust-av/repos?type=all').then(function(res){return res.json();}).then(function(json){data=json;document.getElementById("repos").innerHTML=data.length;})});</script><script>$(document).ready(function(){let data;let stargazersCount=0;fetch('https://api.github.com/orgs/rust-av/repos?type=all').then(function(res){return res.json();}).then(function(json){data=json;data.map((data)=>{stargazersCount=stargazersCount+data.stargazers_count
document.getElementById("stars").innerHTML=stargazersCount})})})</script><script>$(document).ready(function(){let data;let forksCount=0;fetch('https://api.github.com/orgs/rust-av/repos?type=all').then(function(res){return res.json();}).then(function(json){data=json;data.map((data)=>{forksCount=forksCount+data.forks_count
document.getElementById("forks").innerHTML=forksCount})})})</script><script>$(document).ready(function(){let data;let openIssuesCount=0;fetch('https://api.github.com/orgs/rust-av/repos?type=all').then(function(res){return res.json();}).then(function(json){data=json;data.map((data)=>{openIssuesCount=openIssuesCount+data.open_issues_count
document.getElementById("openissues").innerHTML=openIssuesCount})})})</script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js></script><script type=text/javascript>docsearch({apiKey:'d7b5b785798fe748621bcaa8301a2201',indexName:'tokio',inputSelector:'#search-input',debug:false});</script></body></html>