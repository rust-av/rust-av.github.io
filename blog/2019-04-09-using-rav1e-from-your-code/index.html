<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta http-equiv=x-ua-compatible content="ie=edge"><link rel=apple-touch-icon sizes=120x120 href=https://mindfreeze.videolan.me/rust-av/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://mindfreeze.videolan.me/rust-av/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://mindfreeze.videolan.me/rust-av/favicon-16x16.png><link rel=manifest href=https://mindfreeze.videolan.me/rust-av/manifest.json><meta name=theme-color content=#ffffff><link rel=stylesheet href=https://mindfreeze.videolan.me/rust-av/css/bootstrap-reboot.css><link rel=stylesheet href=https://mindfreeze.videolan.me/rust-av/css/bootstrap.css><link rel=stylesheet href=https://mindfreeze.videolan.me/rust-av/css/font-awesome.min.css><link rel=stylesheet href=https://mindfreeze.videolan.me/rust-av/css/rav1e.css><title>Using rav1e - from your own code - Rust AV</title></head><body><header class="navbar navbar-expand navbar-dark flex-column flex-md-row tk-navbar"><a class=navbar-brand href=https://mindfreeze.videolan.me/rust-av/><img src=https://mindfreeze.videolan.me/rust-av/img/logo.png class=align-middle alt></a><div class="collapse navbar-collapse"><ul class=navbar-nav><li class=nav-item><a class=nav-link href=https://mindfreeze.videolan.me/rust-av/>Home</a></li><li class=nav-item><a class="nav-link  active" href=https://mindfreeze.videolan.me/rust-av/blog/2019-04-25-implementing-tile-encoding-in-rav1e./>Blog</a></li><li class=nav-item><a class=nav-link href=https://mindfreeze.videolan.me/rust-av/community/>Community</a></li></ul></div><ul class="navbar-nav flex-row ml-md-auto d-none d-md-flex"><li class=nav-item><a class="nav-link p-2" href=https://github.com/rust-av target=_blank rel=noopener aria-label=GitHub><svg class="navbar-nav-svg" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 499.36" focusable="false"><title>GitHub</title><path d="M256 0C114.64.0.0 114.61.0 256c0 113.09 73.34 209 175.08 242.9 12.8 2.35 17.47-5.56 17.47-12.34.0-6.08-.22-22.18-.35-43.54-71.2 15.49-86.2-34.34-86.2-34.34-11.64-29.57-28.42-37.45-28.42-37.45-23.27-15.84 1.73-15.55 1.73-15.55 25.69 1.81 39.21 26.38 39.21 26.38 22.84 39.12 59.92 27.82 74.5 21.27 2.33-16.54 8.94-27.82 16.25-34.22-56.84-6.43-116.6-28.43-116.6-126.49.0-27.95 10-50.8 26.35-68.69-2.63-6.48-11.42-32.5 2.51-67.75.0.0 21.49-6.88 70.4 26.24a242.65 242.65.0 0 1 128.18.0c48.87-33.13 70.33-26.24 70.33-26.24 14 35.25 5.18 61.27 2.55 67.75 16.41 17.9 26.31 40.75 26.31 68.69.0 98.35-59.85 120-116.88 126.32 9.19 7.9 17.38 23.53 17.38 47.41.0 34.22-.31 61.83-.31 70.23.0 6.85 4.61 14.81 17.6 12.31C438.72 464.97 512 369.08 512 256.02 512 114.62 397.37.0 256 0z" fill="currentcolor" fill-rule="evenodd" /></svg></a></li></ul></header><div class="container-fluid tk-blog"><div class="row flex-xl-nowrap"><div class="col-12 col-md-3 col-xl-2 tk-sidebar"><div class="tk-docs-toggle d-md-none p-0 d-flex ml-3 collapsed align-item-center"><h1 class=tk-title>Using rav1e - from your own code</h1><button class="btn btn-link" type=button data-toggle=collapse data-target=#tk-docs-nav aria-controls=tk-docs-nav aria-expanded=false aria-label="Toggle docs navigation"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 30 30" width="30" height="30" focusable="false"><title>Menu</title><path stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-miterlimit="10" d="M4 7h22M4 15h22M4 23h22"/></svg></button></div><nav class="tk-links collapse" id=tk-docs-nav><div class="tk-toc-item active"><p class=tk-toc-link>Blog Posts</p><ul class="nav tk-sidenav"><li><a href=https://mindfreeze.videolan.me/rust-av/blog/2019-04-25-implementing-tile-encoding-in-rav1e./>Implementing Tile Encoding in rav1e</a></li><li><a href=https://mindfreeze.videolan.me/rust-av/blog/2019-04-09-using-rav1e-from-your-code/ class=active>Using rav1e - from your own code</a></li><li><a href=https://mindfreeze.videolan.me/rust-av/blog/2019-02-18-why-you-should-care-about-aom-analyzer-tool-e2808b/>Why you should care about AOM Analyzer</a></li></ul></div></nav></div><div class="d-none d-xl-block col-xl-4 tk-toc"><div class=section-nav><nav id=TableOfContents><ul><li><a href=#av1-rav1e-crav1e-an-intro>AV1, Rav1e, Crav1e, an intro</a><ul><li><a href=#rav1e-api>Rav1e API</a><ul><li><a href=#config>Config</a><ul><li><a href=#methods>Methods</a><ul><li><a href=#new-context>new_context</a></li></ul></li></ul></li><li><a href=#context>Context</a><ul><li><a href=#methods-1>Methods</a></li></ul></li><li><a href=#workflow>Workflow</a></li></ul></li><li><a href=#crav1e-api>Crav1e API</a><ul><li><a href=#raconfig>RaConfig</a></li><li><a href=#racontext>RaContext</a></li><li><a href=#raframe>RaFrame</a></li><li><a href=#raencoderstatus>RaEncoderStatus</a></li><li><a href=#workflow-1>Workflow</a></li></ul></li><li><a href=#in-closing>In closing</a><ul><li><a href=#coming-next>Coming next</a></li><li><a href=#thanks>Thanks</a></li></ul></li></ul></li></ul></nav></div></div><main class="col-12 col-md-9 col-xl-7 py-md-3 pl-md-3 tk-content tk-docs"><h1 class=tk-title>Using rav1e - from your own code</h1><p class=tk-date>Luca Barbato</p><h1 id=av1-rav1e-crav1e-an-intro>AV1, Rav1e, Crav1e, an intro</h1><blockquote><p><a href=https://aomedia.org/av1-features/>AV1</a> is a modern video codec brought to you by an alliance of <a href=https://aomedia.org/membership/members/>many</a> different bigger and smaller players in the multimedia field.
I&rsquo;m part of the <a href=https://videolan.org>VideoLAN</a> organization and I spent quite a bit of time on this codec lately.</p></blockquote><hr><blockquote><p><a href=https://github.com/xiph/rav1e/>rav1e</a>: The safest and fastest AV1 encoder, built by many volunteers and Mozilla/Xiph developers.
It is written in <a href=https://rustlang.org>rust</a> and strives to provide good speed, quality and stay maintainable.</p></blockquote><hr><blockquote><p><a href=https://github.com/lu-zero/crav1e>crav1e</a>: A companion <a href=https://doc.rust-lang.org/book/crates-and-modules.html>crate</a>, written by <a href=https://github.com/lu-zero>yours truly</a>, that provides a C-API, so the encoder can be used by C libraries and programs.</p></blockquote><hr><p>This article will just give a quick overview of the API available right now and it is mainly to help people start using it and hopefully report issues and problem.</p><h2 id=rav1e-api>Rav1e API</h2><p>The current API is built around the following 4 structs and 1 enum:</p><ul><li><code>struct Frame</code>: The raw pixel data</li><li><code>struct Packet</code>: The encoded bitstream</li><li><code>struct Config</code>: The encoder configuration</li><li><code>struct Context</code>: The encoder state</li></ul><hr><ul><li><code>enum EncoderStatus</code>: Fatal and non-fatal condition returned by the <code>Context</code>methods.</li></ul><h3 id=config>Config</h3><p>The <code>Config</code> struct currently is simply constructed.</p><pre><code class=language-rust>    struct Config {
        enc: EncoderConfig,
        threads: usize,
    }
</code></pre><p>The <code>EncoderConfig</code> stores all the settings that have an impact to the actual bitstream while settings such as <code>threads</code> are kept outside.</p><pre><code class=language-rust>    let mut enc = EncoderConfig::with_speed_preset(speed);
    enc.width = w;
    enc.height = h;
    enc.bit_depth = 8;
    let cfg = Config { enc, threads: 0 };
</code></pre><blockquote><p><strong>NOTE</strong>: Some of the fields above may be shuffled around until the API is marked as stable.</p></blockquote><h4 id=methods>Methods</h4><h5 id=new-context>new_context</h5><pre><code class=language-rust>    let cfg = Config { enc, threads: 0 };
    let ctx: Context&lt;u8&gt; = cfg.new_context();
</code></pre><p>It produces a new encoding context. Where <code>bit_depth</code> is <em>8</em>, it is possible to use an optimized <code>u8</code> codepath, otherwise <code>u16</code> must be used.</p><h3 id=context>Context</h3><p>It is produced by <code>Config::new_context</code>, its implementation details are hidden.</p><h4 id=methods-1>Methods</h4><p>The <code>Context</code> can be grouped into <strong>essential</strong>, <strong>optional</strong> and <strong>convenience</strong>.</p><pre><code class=language-rust>    // Essential API
    pub fn send_frame&lt;F&gt;(&amp;mut self, frame: F) -&gt; Result&lt;(), EncoderStatus&gt;
      where F: Into&lt;Option&lt;Arc&lt;Frame&lt;T&gt;&gt;&gt;&gt;, T: Pixel;
    pub fn receive_packet(&amp;mut self) -&gt; Result&lt;Packet&lt;T&gt;, EncoderStatus&gt;;
</code></pre><p>The encoder works by processing each <code>Frame</code> fed through <code>send_frame</code> and producing each <code>Packet</code> that can be retrieved by <code>receive_packet</code>.</p><pre><code class=language-rust>    // Optional API
    pub fn container_sequence_header(&amp;mut self) -&gt; Vec&lt;u8&gt;;
    pub fn get_first_pass_data(&amp;self) -&gt; &amp;FirstPassData;
</code></pre><p>Depending on the container format, the <code>AV1</code> Sequence Header could be stored in the extradata. <code>container_sequence_header</code> produces the data pre-formatted to be simply stored in <code>mkv</code> or <code>mp4</code>.</p><p><code>rav1e</code> supports multi-pass encoding and the encoding data from the first pass can be retrieved by calling <code>get_first_pass_data</code>.</p><pre><code class=language-rust>    // Convenience shortcuts
    pub fn new_frame(&amp;self) -&gt; Arc&lt;Frame&lt;T&gt;&gt;;
    pub fn set_limit(&amp;mut self, limit: u64);
    pub fn flush(&amp;mut self) {
</code></pre><ul><li><code>new_frame()</code> produces a frame according to the dimension and pixel format information in the Context.</li><li><code>flush()</code> is functionally equivalent to call <code>send_frame(None)</code>.</li><li><code>set_limit()</code>is functionally equivalent to call <code>flush()</code>once <code>limit</code> frames are sent to the encoder.</li></ul><h3 id=workflow>Workflow</h3><p>The workflow is the following:</p><ol><li><p>Setup:</p><ul><li>Prepare a <code>Config</code></li><li>Call <code>new_context</code> from the <code>Config</code> to produce a <code>Context</code></li></ul></li><li><p>Encode loop:</p><ul><li>Pull each <code>Packet</code> using <code>receive_packet</code>.</li><li>If <code>receive_packet</code> returns <code>EncoderStatus::NeedMoreData</code><ul><li>Feed each <code>Frame</code> to the <code>Context</code> using <code>send_frame</code></li></ul></li></ul></li><li><p>Complete the encoding</p><ul><li>Issue a <code>flush()</code> to encode each pending <code>Frame</code> in a final <code>Packet</code>.</li><li>Call <code>receive_packet</code> until <code>EncoderStatus::LimitReached</code> is returned.</li></ul></li></ol><h2 id=crav1e-api>Crav1e API</h2><p>The <a href=https://github.com/lu-zero/crav1e>crav1e</a> API provides the same structures and features beside few key differences:</p><ul><li><p>The <code>Frame</code>, <code>Config</code>, and <code>Context</code> structs are <em>opaque</em>.</p><pre><code class=language-c>typedef struct RaConfig RaConfig;
typedef struct RaContext RaContext;
typedef struct RaFrame RaFrame;
</code></pre></li><li><p>The <code>Packet</code> struct exposed is much simpler than the <code>rav1e</code> original.</p><pre><code class=language-c>typedef struct {
const uint8_t *data;
size_t len;
uint64_t number;
RaFrameType frame_type;
} RaPacket;
</code></pre></li><li><p>The EncoderStatus includes a <code>Success</code> condition.</p><pre><code class=language-c>typedef enum {
RA_ENCODER_STATUS_SUCCESS = 0,
RA_ENCODER_STATUS_NEED_MORE_DATA,
RA_ENCODER_STATUS_ENOUGH_DATA,
RA_ENCODER_STATUS_LIMIT_REACHED,
RA_ENCODER_STATUS_FAILURE = -1,
} RaEncoderStatus;
</code></pre></li></ul><h3 id=raconfig>RaConfig</h3><p>Since the configuration is <code>opaque</code> there are a number of functions to assemble it:</p><ul><li><code>rav1e_config_default</code> allocates a default configuration.</li><li><code>rav1e_config_parse</code> and <code>rav1e_config_parse_int</code> set a specific <code>value</code> for a specific field selected by a <code>key</code> string.</li><li><p><code>rav1e_config_set_${field}</code> are specialized setters for complex information such as the color description.</p><pre><code class=language-c>RaConfig *rav1e_config_default(void);

/**
* Set a configuration parameter using its key and value as string.
* Available keys and values
* - &quot;quantizer&quot;: 0-255, default 100
* - &quot;speed&quot;: 0-10, default 3
* - &quot;tune&quot;: &quot;psnr&quot;-&quot;psychovisual&quot;, default &quot;psnr&quot;
* Return a negative value on error or 0.
*/
int rav1e_config_parse(RaConfig *cfg, const char *key, const char *value);

/**
* Set a configuration parameter using its key and value as integer.
* Available keys and values are the same as rav1e_config_parse()
* Return a negative value on error or 0.
*/
int rav1e_config_parse_int(RaConfig *cfg, const char *key, int value);

/**
* Set color properties of the stream.
* Supported values are defined by the enum types
* RaMatrixCoefficients, RaColorPrimaries, and RaTransferCharacteristics
* respectively.
* Return a negative value on error or 0.
*/
int rav1e_config_set_color_description(RaConfig *cfg,
                                   RaMatrixCoefficients matrix,
                                   RaColorPrimaries primaries,
                                   RaTransferCharacteristics transfer);

/**
* Set the content light level information for HDR10 streams.
* Return a negative value on error or 0.
*/
int rav1e_config_set_content_light(RaConfig *cfg,
                               uint16_t max_content_light_level,
                               uint16_t max_frame_average_light_level);

/**
* Set the mastering display information for HDR10 streams.
* primaries and white_point arguments are RaPoint, containing 0.16 fixed point values.
* max_luminance is a 24.8 fixed point value.
* min_luminance is a 18.14 fixed point value.
* Returns a negative value on error or 0.
*/
int rav1e_config_set_mastering_display(RaConfig *cfg,
                                   RaPoint primaries[3],
                                   RaPoint white_point,
                                   uint32_t max_luminance,
                                   uint32_t min_luminance);

void rav1e_config_unref(RaConfig *cfg);
</code></pre></li></ul><p>The bare minimum setup code is the following:</p><pre><code class=language-c>    int ret = -1;
    RaConfig *rac = rav1e_config_default();
    if (!rac) {
        printf(&quot;Unable to initialize\n&quot;);
        goto clean;
    }

    ret = rav1e_config_parse_int(rac, &quot;width&quot;, 64);
    if (ret &lt; 0) {
        printf(&quot;Unable to configure width\n&quot;);
        goto clean;
    }

    ret = rav1e_config_parse_int(rac, &quot;height&quot;, 96);
    if (ret &lt; 0) {
        printf(&quot;Unable to configure height\n&quot;);
        goto clean;
    }

    ret = rav1e_config_parse_int(rac, &quot;speed&quot;, 9);
    if (ret &lt; 0) {
        printf(&quot;Unable to configure speed\n&quot;);
        goto clean;
    }
</code></pre><h3 id=racontext>RaContext</h3><p>As per the <code>rav1e</code> API, the context structure is produced from a configuration and the same <em>send-receive</em> model is used.
The convenience methods aren&rsquo;t exposed and the frame allocation function is actually essential.</p><pre><code class=language-c>// Essential API
RaContext *rav1e_context_new(const RaConfig *cfg);
void rav1e_context_unref(RaContext *ctx);

RaEncoderStatus rav1e_send_frame(RaContext *ctx, const RaFrame *frame);
RaEncoderStatus rav1e_receive_packet(RaContext *ctx, RaPacket **pkt);
</code></pre><pre><code class=language-c>// Optional API
uint8_t *rav1e_container_sequence_header(RaContext *ctx, size_t *buf_size);
void rav1e_container_sequence_header_unref(uint8_t *sequence);
</code></pre><h3 id=raframe>RaFrame</h3><p>Since the frame structure is opaque in C, we have the following functions to create, fill and dispose of the frames.</p><pre><code class=language-c>RaFrame *rav1e_frame_new(const RaContext *ctx);
void rav1e_frame_unref(RaFrame *frame);

/**
 * Fill a frame plane
 * Currently the frame contains 3 planes, the first is luminance followed by
 * chrominance.
 * The data is copied and this function has to be called for each plane.
 * frame: A frame provided by rav1e_frame_new()
 * plane: The index of the plane starting from 0
 * data: The data to be copied
 * data_len: Lenght of the buffer
 * stride: Plane line in bytes, including padding
 * bytewidth: Number of bytes per component, either 1 or 2
 */
void rav1e_frame_fill_plane(RaFrame *frame,
                            int plane,
                            const uint8_t *data,
                            size_t data_len,
                            ptrdiff_t stride,
                            int bytewidth);
</code></pre><h3 id=raencoderstatus>RaEncoderStatus</h3><p>The encoder status enum is returned by the <code>rav1e_send_frame</code> and <code>rav1e_receive_packet</code> and it is possible already to arbitrarily query the context for its status.</p><pre><code class=language-c>RaEncoderStatus rav1e_last_status(const RaContext *ctx);
</code></pre><p>To simulate the rust <a href=https://doc.rust-lang.org/std/fmt/trait.Debug.html>Debug</a> functionality a <code>to_str</code> function is provided.</p><pre><code class=language-c>char *rav1e_status_to_str(RaEncoderStatus status);
</code></pre><h3 id=workflow-1>Workflow</h3><p>The <em>C</em> API workflow is similar to the <em>Rust</em> one, albeit a little more verbose due to the error checking.</p><pre><code class=language-c>    RaContext *rax = rav1e_context_new(rac);
    if (!rax) {
        printf(&quot;Unable to allocate a new context\n&quot;);
        goto clean;
    }
</code></pre><pre><code class=language-c>    RaFrame *f = rav1e_frame_new(rax);
    if (!f) {
        printf(&quot;Unable to allocate a new frame\n&quot;);
        goto clean;
    }
</code></pre><pre><code class=language-c>while (keep_going(i)){
     RaPacket *p;
     ret = rav1e_receive_packet(rax, &amp;p);
     if (ret &lt; 0) {
         printf(&quot;Unable to receive packet %d\n&quot;, i);
         goto clean;
     } else if (ret == RA_ENCODER_STATUS_SUCCESS) {
         printf(&quot;Packet %&quot;PRIu64&quot;\n&quot;, p-&gt;number);
         do_something_with(p);
         rav1e_packet_unref(p);
         i++;
     } else if (ret == RA_ENCODER_STATUS_NEED_MORE_DATA) {
         RaFrame *f = get_frame_by_some_mean(rax);
         ret = rav1e_send_frame(rax, f);
         if (ret &lt; 0) {
            printf(&quot;Unable to send frame %d\n&quot;, i);
            goto clean;
        } else if (ret &gt; 0) {
        // Cannot happen in normal conditions
            printf(&quot;Unable to append frame %d to the internal queue\n&quot;, i);
            abort();
        }
     } else if (ret == RA_ENCODER_STATUS_LIMIT_REACHED) {
         printf(&quot;Limit reached\n&quot;);
         break;
     }
}
</code></pre><h2 id=in-closing>In closing</h2><p>This article was mainly a good excuse to try <a href=https://dev.to>dev.to</a> and see write down some notes and clarify my ideas on what had been done API-wise so far and what I should change and improve.</p><p>If you managed to read till here, your feedback is really welcome, please feel free to comment, try the software and open issues for <a href=https://github.com/lu-zero/crav1e/issues/new>crav1e</a> and <a href=https://github.com/xiph/rav1e/issues/new>rav1e</a>.</p><h3 id=coming-next>Coming next</h3><ul><li>Working <strong>crav1e</strong> got me to see what&rsquo;s good and what is lacking in the <a href=https://blogs.gentoo.org/lu_zero/2018/12/30/making-and-using-c-compatible-libraries-in-rust-present-and-future/>c-interoperability story</a> of <em>rust</em>, now that <a href=https://github.com/rust-lang/cargo/pull/6298>this</a> landed I can start crafting and publishing better tools for it and maybe I&rsquo;ll talk more about it here.</li><li>Soon <strong>rav1e</strong> will get more threading-oriented features, some benchmarking experiments will happen soon.</li></ul><h3 id=thanks>Thanks</h3><ul><li>Special thanks to <a href=https://github.com/dwbuiten>Derek</a> and <a href=https://github.com/kodabb/>Vittorio</a> spent lots of time integrating <code>crav1e</code> in larger software and gave precious feedback in what was missing and broken in the initial iterations.</li><li>Thanks to <a href=http://github.com/barrbrain/>David</a> for the review and editorial work.</li><li>Also thanks to <a href=https://dev.to/naufraghi>Matteo</a> for introducing me to <a href=https://dev.to>dev.to</a>.</li></ul><div class=tk-next><b>Next up</b>: <a href=https://mindfreeze.videolan.me/rust-av/blog/2019-04-25-implementing-tile-encoding-in-rav1e./>Implementing Tile Encoding in rav1e</a></div></main></div></div><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js integrity=sha384-3ceskX3iaEnIogmQchP8opvBy3Mi7Ce34nWjpBIwVTHfGYWQS9jwHDVRnpKKHJg7 crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/tether/1.3.7/js/tether.min.js integrity=sha384-XTs3FgkjiBgo8qjEjBk0tGmf3wPrWtA6coPfQDfFEY8AnYJwjalXCiosYRBIBZX8 crossorigin=anonymous></script><script src=https://mindfreeze.videolan.me/rust-av/js/bootstrap.min.js></script><script src=https://mindfreeze.videolan.me/rust-av/js/highlight.js></script><script>$(function(){$("pre code").each(function(i,block){if(block.className.indexOf('language-rust')>=0){var new_content='';var lines=block.textContent.split('\n');for(var i=0;i<lines.length;i++){if(lines[i].indexOf('# ')==0||lines[i]=='#'){continue}
new_content+=lines[i].trimRight()+'\n';}
block.textContent=new_content.replace(/\n\n\n/g,"\n\n").trimRight();}
hljs.highlightBlock(block);});});</script><script>$(document).ready(function(){let data;fetch('https://api.github.com/orgs/rust-av/repos?type=all').then(function(res){return res.json();}).then(function(json){data=json;document.getElementById("repos").innerHTML=data.length;})});</script><script>$(document).ready(function(){let data;let stargazersCount=0;fetch('https://api.github.com/orgs/rust-av/repos?type=all').then(function(res){return res.json();}).then(function(json){data=json;data.map((data)=>{stargazersCount=stargazersCount+data.stargazers_count
document.getElementById("stars").innerHTML=stargazersCount})})})</script><script>$(document).ready(function(){let data;let forksCount=0;fetch('https://api.github.com/orgs/rust-av/repos?type=all').then(function(res){return res.json();}).then(function(json){data=json;data.map((data)=>{forksCount=forksCount+data.forks_count
document.getElementById("forks").innerHTML=forksCount})})})</script><script>$(document).ready(function(){let data;let openIssuesCount=0;fetch('https://api.github.com/orgs/rust-av/repos?type=all').then(function(res){return res.json();}).then(function(json){data=json;data.map((data)=>{openIssuesCount=openIssuesCount+data.open_issues_count
document.getElementById("openissues").innerHTML=openIssuesCount})})})</script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js></script><script type=text/javascript>docsearch({apiKey:'d7b5b785798fe748621bcaa8301a2201',indexName:'tokio',inputSelector:'#search-input',debug:false});</script></body></html>